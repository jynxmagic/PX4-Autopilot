/****************************************************************************
 *
 *   Copyright (c) 2013-2019 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/**
 * @file ControlAllocator.cpp
 *
 * Control allocator.
 *
 * @author Julien Lecoeur <julien.lecoeur@gmail.com>
 */

#include "ControlAllocator.hpp"

#include <drivers/drv_hrt.h>
#include <circuit_breaker/circuit_breaker.h>
#include <mathlib/math/Limits.hpp>
#include <mathlib/math/Functions.hpp>
// #include <iostream>
// #include <chrono>

using namespace matrix;
using namespace time_literals;

// #include <iostream>

ControlAllocator::ControlAllocator() :
	ModuleParams(nullptr),
	ScheduledWorkItem(MODULE_NAME, px4::wq_configurations::rate_ctrl),
	_loop_perf(perf_alloc(PC_ELAPSED, MODULE_NAME": cycle"))
{
	_control_allocator_status_pub[0].advertise();
	_control_allocator_status_pub[1].advertise();

	_actuator_motors_pub.advertise();
	_actuator_servos_pub.advertise();
	_actuator_servos_trim_pub.advertise();

	for (int i = 0; i < MAX_NUM_MOTORS; ++i) {
		char buffer[17];
		snprintf(buffer, sizeof(buffer), "CA_R%u_SLEW", i);
		_param_handles.slew_rate_motors[i] = param_find(buffer);
	}

	for (int i = 0; i < MAX_NUM_SERVOS; ++i) {
		char buffer[17];
		snprintf(buffer, sizeof(buffer), "CA_SV%u_SLEW", i);
		_param_handles.slew_rate_servos[i] = param_find(buffer);
	}

	parameters_updated();
	hover_thrust = 0.6f;
	min_hover_thrust = 0.6f;
}

ControlAllocator::~ControlAllocator()
{
	for (int i = 0; i < ActuatorEffectiveness::MAX_NUM_MATRICES; ++i) {
		delete _control_allocation[i];
	}

	delete _actuator_effectiveness;

	perf_free(_loop_perf);
}

bool
ControlAllocator::init()
{
	if (!_vehicle_torque_setpoint_sub.registerCallback()) {
		PX4_ERR("callback registration failed");
		return false;
	}

	a0 = a1 = a2 = a3 = 0;

	if (!_vehicle_thrust_setpoint_sub.registerCallback()) {
		PX4_ERR("callback registration failed");
		return false;
	}

	// fs.open("/home/lunet/ttcc4/PX4-Autopilot/test2.csv");

#ifndef ENABLE_LOCKSTEP_SCHEDULER // Backup schedule would interfere with lockstep
	ScheduleDelayed(50_ms);
#endif
{
float policy_network_w0_inp[32][16] { 
    {-0.010716482f, 0.12433914f, -0.16920814f, -0.51465774f, 0.69276994f, 0.23905538f, -0.039456736f, -0.1301608f, 0.1024582f, -0.03527873f, 0.07921698f, -0.3709457f, 0.24872604f, -0.16639495f, 0.03820209f, 0.16969304f},
    {-0.50421107f, -0.36877555f, -0.35660967f, -0.7343424f, -0.2764894f, -0.25026697f, -0.25807562f, -0.16331737f, 0.12526865f, 0.5226649f, 0.06393666f, 0.08950878f, -0.8788638f, -0.55923975f, -0.6456412f, -0.52289164f},
    {-0.020566985f, -0.16809997f, 0.0067512034f, -0.6598697f, 0.15377952f, -0.33710358f, 0.26779157f, -0.028836885f, -0.33818164f, -0.18128577f, -0.027063055f, -0.36816266f, -0.108157344f, -0.15509571f, -0.3174412f, -0.16847263f},
    {-0.012230821f, 0.19985007f, -0.09799924f, -1.0378456f, -0.09983112f, -0.17808446f, 0.26193297f, 0.014242889f, -0.032521617f, 0.01791767f, 0.14041314f, -0.42930734f, 0.3259689f, -0.12410459f, -0.17222463f, 0.17071493f},
    {-0.6090339f, -0.02948408f, 0.20669635f, -0.1002733f, -0.30327493f, 0.51822066f, 0.12517653f, -0.12647194f, -0.35405493f, 0.11469624f, 0.6188715f, 0.32605347f, -0.3955342f, 0.07451121f, -0.2934002f, -0.62526524f},
    {0.38696823f, 0.09059281f, 0.2552244f, -0.39079827f, -0.45906138f, 0.5365009f, -0.263482f, 0.14032906f, -0.18652275f, -0.09048486f, -0.014174753f, -0.15024959f, -0.16022523f, 0.2654351f, -0.03117414f, -0.10645051f},
    {0.048200596f, 0.13228977f, 0.382706f, 0.54260856f, 0.742737f, -0.31289193f, -0.13286115f, -0.2245553f, -0.23122004f, -0.08985853f, -0.1862313f, -0.036445003f, 0.17425822f, -0.0976374f, -0.20451812f, -0.37106276f},
    {0.10673914f, 0.39748898f, -0.16668396f, 0.27576983f, -1.1621528f, -0.6264925f, 0.10825026f, -0.37416494f, 0.23265396f, 0.07199278f, -0.19261818f, 0.19506046f, 0.3987037f, -0.011153383f, 0.17094095f, 0.16818199f},
    {0.14050752f, -0.037306402f, -0.3141037f, -0.64091337f, 0.48222f, -0.62852204f, -0.14471115f, 0.08216728f, 0.31730103f, 0.23358959f, -0.08568846f, -0.6451435f, -0.04184671f, 0.25352922f, 0.086510874f, 0.03580573f},
    {-0.3286657f, -0.060792904f, -0.4185476f, -0.53437436f, -0.10256747f, -0.20239997f, 0.15981275f, -0.23613273f, -0.35086557f, 0.17414697f, 0.18195626f, -0.2142743f, -0.1613399f, -0.6144217f, 0.18341394f, -0.43057734f},
    {0.099948615f, 0.046145383f, -0.22274503f, -0.010478309f, 0.35759026f, -0.40217975f, -0.34245098f, 0.07988817f, 0.16575672f, -0.20438749f, -0.15557812f, -0.09590711f, -0.19881268f, 0.24588855f, 0.048998717f, -0.47389057f},
    {-0.058904745f, -0.03293985f, 0.3369934f, -0.1352519f, 0.96654564f, 1.224153f, 0.4128285f, -0.21422738f, -0.16047098f, 0.40378577f, 0.24186717f, -0.45812097f, 0.10796606f, -0.08252085f, 0.22848083f, 0.08808305f},
    {-0.55378115f, -0.19143714f, 0.15596381f, 0.0811414f, -0.68190104f, -0.4609625f, 0.37030712f, -0.08360654f, -0.22550887f, -0.3336355f, -0.075272895f, 0.5401689f, 0.095866986f, -0.07946846f, -0.031620037f, -0.1602396f},
    {-0.17713617f, -0.05227692f, -0.24204583f, 0.0018479365f, 0.7396846f, -0.06948919f, -0.49006566f, -0.13936737f, 0.24756214f, -0.23115796f, 0.12323187f, 0.40463966f, -0.9693371f, -0.43651593f, -0.10386212f, -0.12934676f},
    {-0.39383498f, -0.06268991f, 0.15319894f, 0.14926775f, -0.22084002f, 0.19686782f, 0.28786185f, 0.32833853f, -0.29262406f, -0.001994867f, -0.27254245f, -0.06935328f, -0.1697407f, -0.15428004f, -0.46043622f, 0.24879368f},
    {-0.08211161f, -0.5054982f, 0.1902458f, -0.7660115f, -0.33231986f, -0.31861597f, -0.19321543f, 0.2954016f, 0.067112245f, 0.21897718f, -0.1912271f, -0.4029338f, -0.52964425f, -1.003393f, -0.41579506f, -0.84881806f},
    {-0.22541417f, 0.16292913f, -0.21500228f, -0.03475487f, 0.989597f, 0.023317188f, 0.10314489f, 0.12270798f, -0.15773301f, 0.031368367f, -0.35549116f, 0.14406943f, -0.100735314f, -0.20766988f, -0.37356743f, -0.5487434f},
    {0.059211135f, 0.32993656f, -0.067691825f, -0.61027515f, -1.1121216f, -0.830693f, -0.019387448f, -0.14208421f, 0.044044618f, 0.017707717f, 0.01001814f, 0.06862265f, -0.1615679f, -0.24218011f, -0.76050335f, -0.45400584f},
    {-0.036564797f, -0.054638166f, 0.23173776f, -0.2651168f, 0.11800346f, -0.6972983f, 0.063848406f, -0.040863656f, -0.3568726f, -0.27727562f, -0.12285292f, -0.5853427f, -0.34398708f, -0.3298312f, 0.02737319f, -0.5120057f},
    {0.014194214f, -0.02125798f, -0.08564282f, -0.34329104f, -0.89776045f, 0.54042566f, -0.08052798f, -0.16646151f, 0.0016003628f, -0.11330957f, -0.5176037f, 0.1520454f, 0.1121649f, -0.0823864f, -0.2278743f, -0.42700937f},
    {0.3025341f, -0.019120565f, -0.20236363f, 0.8319647f, -0.038190886f, -0.19540334f, -0.2926984f, -0.124207914f, -0.03690679f, 0.23206757f, 0.37383306f, -0.060443547f, -0.15511847f, -0.23108087f, -0.28121477f, -0.433772f},
    {0.036469843f, 0.26532724f, 0.12514527f, 0.18236817f, 0.48386878f, -0.89654756f, -0.0016004703f, -0.0070312456f, -0.00013990593f, -0.16553819f, 0.13574094f, 0.043623306f, 0.18448557f, -0.1416444f, 0.47482514f, 0.44488087f},
    {-0.16577148f, -0.21757197f, 0.16593152f, -0.03821524f, 0.3282771f, 0.40159813f, -0.36018836f, 0.25253543f, -0.27038196f, -0.17916194f, 0.1870449f, -0.4032554f, 0.27243826f, -0.7009518f, -0.45475098f, -0.38581643f},
    {-0.14157523f, 0.31986314f, -0.14547415f, 0.23299162f, 0.31784177f, 1.1651456f, 0.13129614f, -0.15407176f, 0.16883692f, 0.2300268f, -0.11258052f, 0.16655254f, 0.4049772f, -0.062223684f, 0.26294157f, 0.17706192f},
    {-0.33152863f, -0.060125593f, -0.038507085f, -0.7648299f, 0.6367492f, 0.019520205f, 0.3291053f, -0.06380146f, -0.0036136971f, -0.12276218f, 0.15364069f, -0.5146065f, -0.08353112f, -0.15532267f, 0.241984f, 0.4240965f},
    {0.13162681f, 0.1473884f, 0.09338109f, 0.9226954f, 0.70460224f, -0.20492238f, 0.11117255f, 0.14723505f, -0.13978207f, 0.019161956f, 0.07085523f, 0.3374059f, -0.041033145f, -0.03308515f, 0.072143264f, 0.35360315f},
    {0.038026378f, 0.25093552f, 0.21719342f, -0.21006885f, -0.685129f, -0.16664246f, 0.1998062f, -0.21188699f, -0.22009872f, 0.20934127f, -0.152696f, -0.44425166f, 0.10982112f, 0.045459114f, 0.19586492f, 0.3651006f},
    {0.0007342282f, 0.03294633f, -0.14219987f, 0.33967736f, -0.47346252f, -0.040302496f, 0.04598568f, 0.31552365f, 0.26204795f, -0.23796894f, 0.0821354f, -0.49145925f, -0.2201719f, 0.0650243f, 0.39792854f, -0.06418526f},
    {0.08046757f, -0.044422284f, -0.15316173f, -0.18960044f, 0.16361684f, -0.0073439665f, -0.017824672f, 0.26863822f, 0.22495627f, 0.04950076f, 0.012582736f, 0.4761683f, 0.53531617f, 0.031866968f, 0.6308991f, -0.0035739453f},
    {-0.32852292f, -0.11488435f, 0.068504944f, -0.3759311f, 0.2966971f, -0.8632006f, 0.08686681f, -0.14706504f, 0.08300864f, -0.37106606f, 0.30788642f, 0.1661916f, 0.028395383f, -0.16349368f, -0.25979316f, -0.497949f},
    {-0.09515833f, 0.051550906f, 0.50412804f, -0.24949615f, 0.06290406f, -0.10587629f, -0.3016407f, 0.19310875f, -0.143555f, 0.023628157f, 0.03306253f, -0.2486917f, 0.14898004f, 0.23644234f, 0.3309788f, 0.091116965f},
    {-0.37012547f, -0.086318634f, 0.0672489f, 0.2885627f, -0.43733108f, -0.76800114f, 0.4233042f, 0.3480989f, 0.055056833f, 0.08479555f, -0.049887653f, 0.040354665f, -0.41732746f, 0.13891211f, -0.27054882f, -0.68477404f},
};

policy_network_w0.setData(policy_network_w0_inp);
}
{
float policy_network_b0_inp[32][1] { { 0.08767621f }, { -0.55128706f }, { -0.24968393f }, { 0.22692814f }, { -0.34934133f }, { 0.38831744f }, { -0.046951942f }, { 0.11110572f }, { 0.057754923f }, { -0.43747318f }, { -0.17457658f }, { 0.16978945f }, { -0.17056647f }, { -0.5795353f }, { -0.2889328f }, { -0.3995285f }, { -0.38097766f }, { -0.30778626f }, { -0.2848411f }, { 0.31246966f }, { -0.30099332f }, { 0.4244938f }, { -0.46432054f }, { 0.34894624f }, { 0.09667904f }, { 0.29563105f }, { 0.18979032f }, { -0.030924002f }, { 0.44630963f }, { -0.38736904f }, { 0.028958175f }, { -0.2960127f } };

policy_network_b0.setData(policy_network_b0_inp);
}
{
float policy_network_w1_inp[32][32] { 
    {-0.20704086f, 0.09763096f, -0.6263771f, 0.079388335f, 0.16688533f, -0.88927174f, 0.07223006f, -0.540237f, -0.4217554f, -0.19807689f, -0.41773188f, -0.06465143f, 0.021057332f, 0.14095567f, 0.17593907f, 0.48886675f, -0.8592126f, -0.11412025f, -0.3787616f, 0.0063254167f, 0.0025070629f, -0.023636345f, 0.027919907f, -0.20823048f, 0.17662923f, -0.12301318f, 0.09999011f, -0.7062858f, -0.3424182f, 0.21769916f, -0.07035803f, -0.041295517f},
    {0.10612527f, -0.31281152f, 0.16824825f, 0.11343951f, 0.5155641f, -0.16740598f, 0.10734665f, 0.09122353f, -0.18140967f, 0.30017027f, -0.091952935f, 0.042467803f, 0.31079033f, 0.25601032f, 0.48271063f, -0.36081636f, 0.25582993f, -0.34363377f, 0.18305285f, -0.28883538f, 0.34221897f, -0.42020804f, 0.0035304704f, 0.04014997f, 0.26614395f, -0.65744424f, -0.004717241f, -0.14974537f, 0.13904986f, 0.4815834f, -0.08596971f, 0.07482159f},
    {0.40467295f, -0.07986771f, -0.0853436f, -0.5328453f, -0.34965396f, -0.09122856f, -0.17313424f, 0.19218129f, -0.71943635f, -0.3737847f, -0.46989778f, -0.29488534f, 0.3062156f, -0.18681146f, -0.23509987f, -0.7597359f, -0.3450223f, 0.0030562207f, 0.11426923f, -0.45818478f, 0.21239011f, 0.23878859f, -0.009241802f, 0.34685087f, -0.4475216f, 0.13321386f, 0.093317516f, -0.24597113f, 0.2310289f, -0.4536531f, 0.06537418f, 0.4088488f},
    {0.47375727f, 0.22530103f, -0.009580428f, 0.31070554f, 0.1582866f, -0.20010464f, -0.2844003f, -0.20386758f, -0.40900847f, 0.5293337f, -0.19640301f, 0.5617258f, -0.30672583f, 0.2732036f, 0.110968f, -0.35465038f, -0.025621584f, -0.40834907f, 0.17550884f, -0.10726165f, -0.48142537f, 0.17404975f, 0.3647627f, 0.2256728f, -0.1261944f, 0.20959997f, 0.3092196f, -0.06684203f, -0.2844673f, 0.35295162f, -0.051223997f, -0.15972872f},
    {-0.06486449f, -0.15468043f, 0.08793578f, -0.047949634f, 0.07131711f, 0.2886763f, -0.048670985f, -0.28450522f, 0.3654598f, -0.5610706f, 0.4502356f, 0.22282217f, -0.74718785f, 0.40236548f, -0.09779582f, 0.4679825f, -0.07041351f, -0.5373721f, -0.1613455f, -0.004704774f, 0.073273286f, -0.050642528f, -0.22659028f, 0.398005f, 0.16977431f, -0.23026708f, 0.2634196f, -0.2915681f, 0.26035362f, 0.5280417f, -0.35769767f, 0.00498494f},
    {0.022244846f, 0.13857369f, -0.1780386f, -0.68963265f, -0.32721293f, 0.4661741f, 0.2572927f, 0.21436492f, -0.2726962f, -0.082136095f, 0.10912176f, -0.08115695f, -0.1535616f, 0.2454477f, 0.1213623f, 0.57652587f, 0.1993758f, -1.15876f, -0.047095634f, -0.36324713f, -0.2938895f, -0.05197533f, -0.08023367f, 0.04842292f, -0.6174913f, 0.13351218f, 0.5388228f, 0.07831607f, -0.022223478f, -0.03832741f, -0.010395522f, 0.18634233f},
    {0.13308905f, 0.0679104f, 0.20923464f, 0.28286773f, -0.3748686f, -0.24579403f, 0.40784422f, -0.51940477f, -0.12743504f, 0.2280942f, 0.28329194f, -0.09344691f, -0.21683593f, 0.13829616f, 0.08682378f, 0.21818402f, 0.023269381f, 0.21918187f, 0.29617465f, -0.507055f, 0.5218592f, 0.3759321f, -0.36923f, 0.18384902f, -0.23691325f, 0.11668576f, -0.26831037f, 0.12416462f, 0.369207f, -0.17175807f, -0.27057686f, 0.075075574f},
    {-0.6120509f, -0.42453456f, 0.24955544f, -0.10175062f, 0.02954853f, -0.043986775f, 0.4060958f, 0.13032317f, -0.29573318f, -0.45798546f, -0.24377646f, -0.24861434f, -0.3346447f, 0.27932143f, 0.092387706f, 0.12938106f, 0.26611876f, -0.44173083f, 0.34468892f, 0.2686671f, 0.27292666f, 0.21713172f, 0.17796488f, -0.30201823f, -0.12972751f, 0.23551396f, -0.29090503f, 0.22338325f, 0.10554475f, -0.022193745f, 0.11267532f, -0.6676714f},
    {0.057448696f, 0.60000724f, -0.23966496f, -0.37653688f, 0.36586818f, -0.44495255f, -0.17923297f, -0.06957603f, -0.18801333f, -0.11857393f, 0.33315983f, 0.3420777f, 0.29420868f, 0.057972565f, 0.25056067f, 0.29856423f, 0.40239313f, 0.12471105f, 0.26132864f, 0.2541887f, 0.24446596f, 0.24161635f, 0.46306375f, -0.019182388f, 0.084236726f, -0.6964803f, -0.12660785f, 0.11444884f, -0.37549445f, 0.3872646f, 0.10216878f, 0.12341308f},
    {-0.13608408f, -0.07805598f, -0.32760596f, -0.1593173f, -0.12389475f, -0.24912868f, 0.32414857f, -0.1214197f, 0.32186395f, 0.17480367f, 0.010302551f, 0.041431937f, 0.17287798f, 0.08355724f, -0.5062048f, 0.1181634f, 0.27979937f, -0.04723687f, 0.11854014f, -0.32184425f, -0.35725862f, 0.57403445f, 0.16796395f, -0.26016828f, 0.25722474f, 0.26751593f, -0.17944996f, -0.186131f, 0.3302279f, 0.1744587f, -0.08223271f, -0.06322285f},
    {0.057202984f, -0.15280524f, -0.08227014f, 0.113364875f, 0.5103768f, -0.047835857f, 0.18094337f, 0.42674047f, 0.04995971f, -0.21176158f, 0.33696818f, -0.5118052f, -0.18411016f, 0.4505121f, -0.53318316f, 0.090501875f, -0.075826116f, -0.51456755f, 0.14451699f, -0.33526117f, -0.2757477f, -0.07520109f, 0.20213014f, 0.03369896f, -0.06521829f, -0.3190188f, -0.35201207f, 0.2554209f, 0.37784022f, -0.24593891f, -0.21814524f, 0.056461897f},
    {-0.05172489f, -0.24756709f, 0.085348584f, 0.096029475f, 0.14113413f, 0.10944425f, -0.05182391f, -0.14520349f, 0.078517035f, 0.075274415f, 0.47025537f, -0.6994074f, 0.47430184f, 0.19497246f, 0.23229845f, 0.09993777f, -0.24860297f, -0.59081316f, 0.06492069f, -0.15282153f, 0.21855824f, 0.33616573f, 0.40696678f, -0.28799978f, -0.15116067f, 0.298477f, 0.30779347f, 0.09647567f, -0.120099016f, 0.5080716f, 0.0033450124f, -0.14649524f},
    {0.19394249f, 0.053849f, -0.41934913f, -0.16196762f, -0.1525507f, -0.49312904f, 0.15337352f, -0.028497512f, 0.12532856f, 0.010096554f, 0.38009277f, -0.07494853f, -0.16356316f, 0.47105703f, -0.49160713f, -0.75310636f, 0.12350755f, 0.15088446f, 0.6308155f, -0.06167012f, 0.025396138f, 0.07368742f, -0.74895936f, -1.0114105f, 0.073698275f, 0.095393f, -0.06924571f, 0.11849413f, -0.27130756f, 0.6389717f, -0.22398184f, 0.23332465f},
    {0.06992578f, -0.55414766f, -0.2415192f, -0.19849959f, 0.3001406f, -0.04649475f, 0.2184491f, -0.10109264f, -0.5724076f, -0.12444306f, 0.13522474f, 0.009596547f, -0.3512428f, -0.19568591f, -0.11329396f, 0.0052065714f, 0.20087105f, 0.015048481f, -0.3620352f, 0.27874303f, 0.2594341f, -0.45139912f, 0.08168743f, -0.039345294f, -0.16501945f, 0.3644909f, -0.5394855f, -0.38330743f, -0.5040704f, 0.4634018f, -0.4513169f, -0.37328205f},
    {0.31219682f, -0.1863779f, -0.33911353f, 0.001721023f, -0.18795443f, -0.12960038f, 0.10883639f, 0.007977119f, -0.2264508f, -0.27830607f, 0.18770583f, -0.08773348f, -0.16858257f, -0.49586555f, 0.3257155f, 0.10481971f, -0.21771389f, -0.1381792f, -0.2019041f, 0.0664997f, -1.3804543f, -0.13230483f, -0.5381592f, 0.73404735f, 0.09323768f, 0.003409258f, -0.36449274f, 0.22536688f, -0.038256984f, -0.5050299f, -0.02862796f, -0.39955294f},
    {0.060786497f, -0.3152457f, -0.040803365f, -0.036881797f, 0.20347777f, 0.0733961f, -0.09019273f, -0.43074784f, 0.258758f, -0.3757707f, 0.04487593f, 0.43811777f, 0.39480063f, -0.26839575f, -0.25044328f, 0.2008832f, -0.13803408f, -0.34395885f, 0.7383889f, 0.011982146f, 0.24748984f, -0.24014296f, -0.18979643f, 0.2161405f, -0.44953296f, 0.01007678f, -0.05144517f, -0.3910705f, 0.09562611f, -0.44949305f, 0.3065078f, -0.34637022f},
    {-0.2352708f, -0.9454158f, -0.47850916f, -0.033888906f, -0.30819285f, -0.4801083f, 0.24238394f, 0.40783206f, 0.22022147f, -0.2638936f, 0.12825944f, -0.24625415f, -0.31457934f, 0.16799878f, 0.17251867f, -0.11343405f, 0.16590309f, -0.052849215f, -0.072856344f, -0.06513269f, 0.19964008f, 0.0929624f, -0.49436688f, -0.36086673f, -0.26262966f, -0.024553005f, 0.2585291f, 0.15456997f, 0.19344535f, -0.4158876f, -0.13830811f, -0.11901865f},
    {0.2641523f, 0.25787392f, -0.14358492f, 0.61432785f, -0.18450086f, -0.008117693f, 0.04766206f, -0.12017608f, 0.12849964f, 0.13086616f, -0.055383913f, -0.5579677f, 0.22597672f, 0.2914348f, -0.08505722f, -0.09636157f, 0.6002719f, -0.7228946f, 0.1910128f, 0.08671395f, -0.26472035f, -0.23666391f, -0.49640623f, 0.122930646f, 0.27198562f, 0.09743418f, 0.1842526f, -0.3473235f, -0.069402605f, 0.013227997f, 0.31176913f, 0.10991836f},
    {0.41935208f, 0.024107827f, -0.43158567f, -0.19963047f, -0.16332072f, 0.24630849f, -0.39408413f, 0.5134812f, 0.55580866f, 0.07766324f, -0.37674284f, -0.3970348f, -0.36445263f, -0.7284252f, 0.015629373f, 0.19273105f, -0.10189284f, -0.51591516f, 0.007950458f, 0.13040246f, 0.34452853f, 0.2543895f, -0.3583184f, 0.08051831f, 0.31543508f, -0.24891944f, 0.004546355f, -0.15288886f, 0.0064589516f, -0.19130482f, -0.094887726f, -0.2852252f},
    {0.39499733f, 0.24368781f, -0.0053458544f, 0.69865423f, 0.009405486f, 0.33608133f, 0.32054433f, -0.37820208f, -0.07803921f, 0.013446026f, -0.20290117f, 0.16769207f, -0.2736101f, -0.39058244f, -0.25956059f, -0.058631096f, 0.108959325f, -0.21543609f, 0.22500493f, 0.0031212233f, -0.0796098f, 0.4229465f, 0.23660399f, 0.033202276f, 0.08598861f, -0.4952189f, 0.2719638f, -0.041511368f, 0.26747528f, -0.09157072f, 0.3840159f, 0.36108238f},
    {0.07841953f, -0.48273367f, -0.3901388f, -0.016976058f, 0.07188373f, 0.28944808f, -0.2967429f, -0.21002926f, -0.044035807f, 0.0054932274f, 0.1597372f, 0.08711364f, -0.05244959f, 0.4061922f, 0.19909975f, -0.21419801f, -0.1027786f, -0.33445424f, -0.2149216f, 0.15875442f, 0.06039286f, -0.045584526f, 0.12444f, -0.55941206f, -0.0022517487f, -0.2012184f, 0.08372875f, 0.14171033f, 0.6239736f, -0.096583195f, 0.4235681f, -0.23348677f},
    {0.028807556f, -0.22348525f, 0.03494972f, 0.113917075f, -0.6475153f, 0.33637205f, 0.05767785f, -0.14657842f, -0.06500505f, -0.30218023f, -0.027154524f, 0.39151695f, -0.27515694f, 0.12018715f, -0.07786269f, 0.24053743f, -0.43473715f, 0.3565799f, 0.28461513f, -0.582849f, 0.010740744f, -0.15055944f, 0.3384902f, 0.053676575f, 0.32185552f, -0.07455892f, -0.31054357f, 0.06701342f, -0.45958245f, 0.322727f, 0.61918676f, -0.14932449f},
    {0.068019934f, -0.4563261f, 0.033570666f, -0.1076072f, -0.07285112f, 0.04027124f, -0.07281688f, -0.92184395f, 0.33776098f, 0.05064929f, -0.54343843f, 0.052278034f, -0.08499333f, -0.32969257f, -0.19146785f, -0.40461245f, 0.3828712f, -0.02274702f, 0.019012742f, 0.08950421f, -0.09350973f, -0.07994703f, -0.10625619f, 0.5215772f, 0.38602343f, 0.46807787f, -0.053502925f, 0.7191852f, 0.08524558f, 0.30803302f, -0.19753022f, 0.16273999f},
    {0.3779444f, 0.24519128f, -0.19970296f, 0.24636343f, -0.39861193f, -0.26755008f, -0.07679881f, -0.05562095f, -0.2006825f, -0.3992707f, 0.0012554432f, 0.00069685205f, -0.49211434f, -0.96517277f, -0.02530427f, 0.010485899f, 0.55234474f, 0.28936225f, -0.2426875f, -0.18724841f, -0.2882463f, -0.6385619f, 0.14904751f, 0.009608358f, -0.119104646f, 0.31941277f, -0.36592212f, 0.16704802f, 0.1620821f, 0.47644955f, -0.16564202f, -0.24145111f},
    {0.30242914f, -0.15156917f, -0.44820312f, 0.30570427f, 0.052745644f, 0.14182109f, -0.19796738f, 0.18823455f, -0.40388384f, 0.35270166f, -0.11121233f, 0.16938473f, 0.104258984f, 0.22863619f, -0.022495287f, -0.14025442f, -0.16290224f, 0.16541077f, -0.4390164f, -0.10891786f, 0.07239806f, -0.9461332f, 0.4014704f, 0.161761f, 0.48450977f, -0.2519858f, 0.17697252f, 0.41961816f, -0.24994066f, -0.42653608f, -0.033509407f, -0.6422525f},
    {0.43258023f, -0.08699293f, 0.34416145f, -0.83505446f, -0.18662776f, -0.76411945f, 0.2632747f, 0.3017085f, 0.1576916f, -0.08430029f, 0.130224f, -0.22248816f, 0.18022223f, -0.04879159f, -0.27876374f, 0.22403921f, 0.12822177f, -0.48087302f, -0.11275984f, 0.24815941f, -0.0123818135f, -0.10738415f, -0.14880607f, -0.17017269f, 0.23747714f, -0.2543294f, 0.24485834f, 0.08981484f, -0.26100773f, 0.1456276f, 0.29086605f, -0.20933077f},
    {-0.07203983f, 0.33136067f, -0.16482536f, -0.4163463f, 0.6791514f, 0.11800286f, 0.27339968f, -0.05374007f, 0.17556381f, 0.115785636f, -0.0155579625f, 0.075342804f, 0.024783947f, 0.14391848f, -0.06940738f, -0.29121017f, -0.567383f, 0.62034243f, 0.3750175f, -0.28132164f, 0.22882755f, 0.124077655f, -0.15706621f, -0.3744146f, 0.15678385f, 0.14814964f, -0.06798186f, 0.13782664f, 0.15514654f, 0.39820883f, 0.26151094f, -0.11922275f},
    {-0.17447245f, -0.49677858f, 0.07796962f, -0.16965981f, 0.011791588f, 0.07108587f, -0.60692626f, 0.14115322f, -0.14013265f, 0.28956765f, -0.2044726f, -0.74352586f, -0.40745008f, -0.5348252f, 0.07338786f, 0.48299354f, 0.15939194f, 0.90136784f, 0.29978344f, -0.0610512f, 0.080091424f, -0.038016982f, -0.35840023f, -0.20638645f, 0.42981216f, -0.43628976f, 0.2184426f, 0.15464488f, -0.12021466f, -0.13391133f, -0.027071942f, 0.09555688f},
    {0.48655066f, 0.20208782f, -0.20452459f, 0.12178506f, 0.04468283f, 0.18241507f, 0.017045837f, 0.32383448f, -0.10482547f, -0.3886425f, -0.42955276f, 0.18336709f, 0.30876538f, -0.24069886f, 0.10428058f, 0.44533408f, -0.10795212f, -0.19843902f, -0.120158486f, 0.16553627f, -0.21718697f, 0.034728654f, -0.43108606f, -0.30732423f, 0.04570259f, 0.037091285f, 0.19565274f, 0.37349114f, -0.16411933f, -0.30016178f, -0.21843427f, -0.06957652f},
    {-0.14915206f, 0.04278429f, -0.055539433f, -0.2671933f, -0.11294407f, 0.20659156f, 0.24113455f, 0.09718697f, -0.39346403f, 0.5179443f, -0.14072776f, -0.043920368f, 0.27736968f, -0.1484571f, 0.059370857f, 0.33908856f, -0.078903034f, 0.48714867f, -0.06624949f, 0.26940423f, 0.25701153f, -0.45672205f, -0.07763575f, 0.43215063f, -0.34101924f, -0.18553437f, 0.20958962f, 0.08475956f, 0.29564294f, 0.5511338f, 0.112443514f, 0.13558494f},
    {0.015024853f, -0.36728504f, 0.051891837f, 0.066328146f, 0.13285096f, -0.0006738698f, -0.597211f, -0.23222321f, -0.6637417f, -0.48010895f, 0.21314292f, 0.19191867f, -0.009828221f, -0.041604485f, -0.91685885f, -0.062257376f, 0.123373866f, -0.0646864f, -0.2202599f, -0.7103387f, -0.16280077f, -0.03038475f, -0.30144846f, 0.19887725f, 0.2558481f, -0.38054743f, -0.29451185f, 0.39573324f, -0.21848573f, 0.6924122f, -0.22134277f, -0.6611529f},
    {-0.6111728f, 0.19859052f, -0.33194086f, 0.062191505f, 0.08066475f, -0.03658605f, -0.34625128f, 0.3218966f, -0.2176485f, 0.10838372f, -0.22897848f, 0.17346351f, 0.067816995f, 0.10066239f, -0.17921954f, 0.58915675f, -0.23615938f, -0.502952f, -0.2725804f, -0.51823854f, 0.18707639f, 0.24188438f, -0.21853076f, 0.14127295f, -0.34625417f, 0.20909697f, -0.2500866f, 0.0803813f, 0.12574297f, 0.033955306f, 0.13112287f, 0.09994196f},
};

policy_network_w1.setData(policy_network_w1_inp);
}
{
float policy_network_b1_inp[32][1] { { 0.14708035f }, { -0.22899689f }, { 0.31385773f }, { -0.02460031f }, { 0.066026665f }, { 0.31670853f }, { 0.2552619f }, { -0.02342252f }, { -0.37774256f }, { 0.08987575f }, { 0.26529714f }, { 0.18718868f }, { -0.47647318f }, { -0.3409189f }, { 0.12226543f }, { -0.073856704f }, { 0.06416429f }, { 0.055566914f }, { 0.1364766f }, { 0.15504706f }, { 0.0087037515f }, { -0.17997815f }, { 0.21499161f }, { -0.33537474f }, { -0.25120476f }, { -0.26572123f }, { 0.029034793f }, { -0.21132645f }, { -0.07366744f }, { -0.0147937415f }, { 0.15686859f }, { 0.2727336f } };

policy_network_b1.setData(policy_network_b1_inp);
}
{
float policy_network_w2_inp[32][32] { 
    {0.25174284f, 0.17994209f, 0.0401268f, 0.060880348f, -0.0681768f, -0.3322288f, -0.24619068f, -0.5134514f, 0.285797f, -0.10675812f, 0.08274284f, -0.25450647f, 0.0040548104f, 0.21719384f, -0.73389506f, -0.11155244f, -0.26750115f, -0.35168034f, 0.053228337f, 0.058942378f, 0.08138352f, 0.2753369f, -1.0496881f, 0.32833913f, 0.18788394f, -0.09525038f, -0.16465357f, 0.19484983f, 0.13642076f, 0.23580769f, 0.5949052f, -0.73932666f},
    {-0.59872884f, 0.050677724f, 0.073889665f, 0.019163815f, -0.028056204f, -0.5452328f, -0.038356844f, -0.23535271f, -0.023061534f, -0.5714295f, -0.650017f, 0.05159037f, -0.25641176f, 0.08392843f, 0.092278875f, -0.47132736f, 0.05239846f, -0.15127777f, -0.11927671f, -0.6438947f, -0.21935916f, -0.38411742f, 0.3966846f, 0.2045559f, 0.6150035f, 0.06614959f, -0.5928025f, 0.16623776f, 0.27043247f, 0.22556695f, 0.38848302f, 0.05309322f},
    {-0.12992814f, 0.027590776f, -0.604868f, -0.06002697f, -0.1511011f, -0.30125144f, 0.25581723f, 0.2892543f, -0.33887154f, 0.21641478f, 0.24506296f, -0.49816114f, 0.1839814f, 0.34349653f, -0.10346983f, -0.4458161f, -0.3231493f, 0.13934404f, 0.45057023f, 0.081422664f, 0.2877014f, 0.21352534f, 0.44156355f, 0.5186727f, -0.17320861f, -0.13502999f, -0.9014009f, -0.020884043f, -0.24429306f, -0.0034619756f, 0.23077713f, -0.08160124f},
    {0.9305688f, -0.40062237f, 0.035812695f, -0.2852903f, -0.076781936f, -0.0606317f, 0.18396357f, -0.16201656f, -0.2916278f, -0.31087705f, 0.33912492f, -0.36281255f, -0.7366467f, 0.043343745f, 0.22988755f, 0.048383627f, 0.334805f, -0.6227786f, 0.2789623f, 0.058057588f, -0.012392752f, 0.62861127f, 0.21221896f, 0.11526622f, -0.23822474f, 0.06232765f, 0.16753356f, -0.122869395f, 0.20062263f, 0.043489967f, -0.38901272f, -0.35350877f},
    {-0.37317342f, -0.75660855f, -0.456399f, 0.1513283f, -0.26929674f, -1.008712f, -0.26128927f, -0.24127507f, -0.11942451f, 0.60839456f, 0.12304305f, -0.108480744f, 0.71247536f, -0.36335722f, 0.065305956f, -0.047946874f, -0.21982507f, 0.13174492f, -0.1413015f, -0.27839336f, -0.07005758f, 0.12977195f, 0.29203746f, -0.06098695f, 0.37169495f, 0.17874353f, 0.14541428f, 0.11796159f, 0.17642187f, -0.040506933f, 0.19257164f, -0.08750832f},
    {0.026952142f, 0.5284938f, 0.025379097f, -0.28032523f, -0.17682694f, -0.034237646f, 0.20055981f, -0.2140627f, 0.17903368f, -0.035019904f, 0.1033582f, -0.3286431f, -0.023327611f, -0.3732057f, 0.18406084f, -0.07528788f, -0.07891077f, 0.52604884f, -0.64018244f, -0.0858598f, -0.34871376f, 0.04686336f, 0.5562236f, -0.07216043f, -0.3120108f, 0.061205704f, -0.25824896f, -0.24985121f, 0.005897495f, 0.5763295f, 0.23963149f, -0.12671703f},
    {-0.16298966f, -0.14117704f, -0.27518028f, -0.23190106f, 0.66704005f, -0.25788817f, 0.19474807f, -0.17880248f, -0.28888646f, 0.46136844f, 0.16339777f, -0.25431308f, -0.55889016f, -0.45615625f, 0.047549505f, 0.05321044f, 0.30324677f, 0.111265026f, -0.11253864f, 0.33807376f, -0.68318653f, -0.08132446f, -0.009053511f, 0.12432346f, -0.3910693f, 0.58507216f, -0.17385791f, -0.26388875f, 0.16780335f, -0.055263694f, 0.6352535f, 0.11656153f},
    {0.07528808f, 0.013375834f, -0.21099609f, -0.34668055f, -0.37475803f, -0.26498175f, -0.012251338f, -0.707017f, -0.020546617f, -0.820681f, 0.5845478f, 0.28437373f, -0.22666503f, -0.2809754f, 0.7602293f, -0.13903561f, 0.32136732f, 0.06456614f, 0.12942989f, -0.68584627f, 0.18211013f, -0.10098178f, -0.024118133f, -0.67736024f, -0.53147995f, -0.10318842f, 0.038075425f, 0.040375143f, -0.112200245f, -0.53746855f, 0.25754213f, -0.23722608f},
    {-0.16907506f, -0.37674487f, -0.16848043f, -0.14911497f, -0.57987595f, -0.0070694885f, 0.07268642f, 0.066852055f, -0.31404665f, 0.24719022f, -0.5666777f, 0.039721962f, -0.4691751f, -0.18758853f, -0.36471674f, 0.08659968f, 0.6008244f, -0.35968617f, 0.63269985f, -0.4924907f, 0.30268547f, 0.111657955f, -0.42038068f, 0.022102732f, -0.059538905f, 0.2369829f, -0.030965602f, -0.5543487f, 0.24271783f, 0.096386336f, 0.104550764f, 0.1720644f},
    {0.23126705f, 0.17778227f, -0.1753717f, -0.10856014f, -0.22732063f, -0.76994157f, -0.19147041f, -0.07658753f, -0.5989234f, -0.096849f, -0.021953832f, -0.24767967f, -0.06312985f, 0.05989555f, 0.032237183f, -0.20506331f, 0.10774058f, -0.20138766f, -0.14159134f, 0.071442224f, -0.27856487f, -0.07283733f, -0.09000837f, 0.27176335f, -0.38411605f, -0.31418294f, 0.511592f, 0.1970273f, 0.23423995f, 0.07610104f, -0.4151708f, 0.11581443f},
    {-0.086919546f, 0.29714242f, 0.12368406f, -0.060685538f, -0.02510337f, 0.1779012f, -0.4429208f, 0.062084503f, -0.50135696f, -0.101270735f, 0.23595403f, 0.10968523f, -0.2578809f, -0.069965184f, 0.67665064f, -0.12547876f, 0.027080704f, -0.06087691f, 0.35063028f, -0.2639928f, -0.02395021f, 0.21063107f, 0.04209824f, 0.08663644f, -0.51969194f, -0.33661973f, 0.2716107f, 0.617144f, -0.30457583f, 0.22115083f, 0.43544826f, 0.00881605f},
    {0.13770649f, 0.6635443f, -0.13395083f, -0.2252423f, 0.40973133f, -0.11263096f, 0.13771068f, 0.20274845f, 0.1696629f, 0.36959186f, 0.18104005f, -0.24524206f, -0.26048988f, 0.5820451f, 0.5032807f, -0.34215704f, -0.45138013f, -0.18005627f, 0.3068869f, -0.36345115f, 0.4333708f, 0.2797822f, 0.22409828f, -0.112510175f, 0.47804368f, 0.49515748f, 0.3102386f, -0.00031518878f, -0.33326042f, -0.07970131f, -0.15160526f, -0.028573832f},
    {0.4854722f, 0.3887823f, -0.35558763f, 0.049960755f, 0.017462306f, -0.30276868f, -0.30964634f, -0.29979184f, 0.6274568f, -0.16829517f, 0.27925327f, 0.3215369f, -0.1400682f, 0.14086333f, -0.5349095f, -0.610325f, 0.3635135f, 0.26489034f, 0.12188275f, 0.34853172f, 0.05643396f, 0.03798155f, 0.044468027f, -0.16805607f, 0.19114578f, -0.15276596f, 0.21510755f, -0.37321365f, 0.048610985f, -0.3214308f, 0.19868259f, 0.1932601f},
    {0.24028945f, -0.10293159f, 0.18146062f, 0.33370534f, 0.18374997f, 0.3833801f, -0.019697275f, -0.28316492f, 0.3947288f, 0.037815966f, -0.34934482f, 0.30913922f, 0.79684305f, 0.21378656f, -0.3579337f, -0.12293481f, -0.012485608f, 0.13095556f, -0.024898034f, -0.15686812f, 0.20180812f, -0.00027983388f, 0.11731836f, 0.33268413f, -0.3935262f, 0.35934395f, 0.1327611f, -0.11706828f, 0.17771123f, 0.2321809f, -0.029886069f, -0.08979298f},
    {-0.62252f, 0.10441799f, -0.28145692f, -0.116989575f, 0.1391244f, 0.11251758f, -0.13286765f, -0.20421009f, -0.30503651f, -0.26134482f, 0.03299201f, -0.14769979f, 0.06305027f, 0.35328117f, -0.23081516f, 0.25108546f, -0.15372269f, 0.35363168f, 0.23595072f, 0.44765848f, 0.43172213f, -0.20604014f, 0.08918022f, 0.19938274f, 0.078445956f, -0.12678707f, 0.272555f, -0.02384996f, -0.3239079f, 0.18044199f, -0.15716435f, -0.09058914f},
    {0.074345194f, -0.18659732f, 0.30495393f, -0.35303628f, -0.3090221f, -0.46360195f, -0.6565775f, -0.27655905f, -0.15236469f, -0.15389101f, -0.41055226f, 0.30992827f, -0.45734832f, -0.28850687f, -0.11960661f, 0.14171354f, -0.5025602f, 0.09631239f, 0.26765168f, 0.29037815f, -0.27284575f, 0.04668077f, -0.15715097f, 0.41959205f, -0.27546856f, -0.118093796f, -0.32872614f, -0.0789369f, -0.7051974f, -0.026237765f, -0.24304675f, -0.21399635f},
    {-0.035539035f, 0.26475683f, -0.044501632f, -0.009804806f, 0.21590604f, -0.122530006f, 0.030914674f, 0.17029898f, 0.53842103f, -0.40187106f, -0.14810812f, 0.12097944f, 0.15997887f, -0.18802619f, -0.0930077f, 0.06925569f, -0.25366837f, -0.0037839143f, -0.21429136f, -0.3045453f, -0.09102321f, 0.5859935f, -0.00240299f, -0.5171801f, -0.41402745f, -0.16886795f, 0.16740476f, 0.39302728f, -0.25178745f, 0.63291097f, -0.49443614f, 0.26690808f},
    {0.68262994f, -0.19349654f, 0.3603696f, -0.22717303f, 0.04945777f, 0.4739902f, -0.7491071f, -0.64217705f, 0.04482528f, -0.05264419f, -0.39736643f, -0.4531863f, 0.021771884f, -0.33114892f, 0.262155f, 0.27838102f, -0.048921265f, -0.39186805f, 0.28396127f, 0.17451419f, -0.22322795f, 0.17121132f, 0.2136045f, 0.09216329f, -0.4083528f, 0.35452983f, -0.18674819f, 0.22703284f, -0.05735024f, -0.079784f, -0.44608492f, 0.4273811f},
    {-0.21549359f, -0.45580295f, 0.013939742f, 0.040457707f, -0.16616337f, -0.26668146f, 0.56194484f, 0.47723308f, 0.13447495f, 0.19675246f, -0.124403514f, -0.22345054f, -0.14139204f, -0.016640801f, 0.014427995f, 0.10597145f, 0.046132684f, 0.31546488f, -0.30377224f, 0.12233245f, 0.19550774f, 0.053782634f, 0.0012460027f, 0.40263155f, -0.10378799f, -0.13018273f, 0.3625417f, 0.23300119f, -0.09767932f, -0.37806416f, 0.63790613f, 0.086744145f},
    {0.21705846f, -0.21923192f, -0.11616224f, -0.046792112f, -0.11233769f, -0.14148436f, 0.46042368f, -0.5011062f, -0.18328324f, -0.15531954f, 0.43753737f, -0.18047953f, -0.8908673f, 0.22195357f, -0.019557683f, -0.21794342f, 0.14547542f, 0.042871658f, 0.32958788f, -0.5423095f, -0.52916116f, -0.36152858f, -0.012949948f, 0.14024839f, -0.054262538f, -0.018784381f, -0.29218397f, -0.78094846f, -0.25591844f, -0.3355435f, -0.09256991f, 0.6071781f},
    {0.011949092f, -0.26527184f, 0.11389452f, 0.48397374f, -0.28909624f, -0.045238774f, 0.23297177f, -0.06845752f, 0.036858544f, 0.41523567f, 0.37169135f, -0.047757536f, 0.18731819f, 0.3475374f, 0.2001387f, -0.36073768f, 0.053136926f, -0.4723054f, -0.21212643f, 0.6665289f, -0.21543652f, -0.04854685f, -0.098037906f, -0.29682508f, 0.08491304f, -0.13120629f, 0.13416786f, -0.23405069f, -0.38701397f, 0.16894943f, 0.20133476f, 0.08815491f},
    {-0.25533018f, -0.056408357f, 0.10568323f, -0.41009203f, -0.4943094f, 0.21861224f, -0.3099862f, -0.56867033f, -0.48919654f, -0.63033867f, -0.5013441f, -1.3855562f, 0.26614073f, -0.4627382f, 0.03496739f, -1.3630072f, -0.20300567f, -0.035393905f, 0.26337555f, -0.931818f, -0.33493358f, 0.016164735f, -1.0611603f, -0.6305959f, 0.7129493f, -0.050283134f, 0.22379412f, 0.043876212f, 0.16020757f, 0.32318798f, -0.28427652f, -0.80964935f},
    {-0.18098535f, -0.70865685f, -0.46269715f, 0.12931976f, 0.08842506f, 0.06811781f, -0.23674667f, 0.2558664f, -0.3642501f, 0.16844149f, 0.28062138f, 0.12523016f, -0.30222863f, 0.36691484f, 0.20011723f, -0.1369396f, -0.33812416f, 0.26653576f, -0.67093545f, -0.091166355f, 0.0784388f, 0.4960531f, -0.19883092f, -0.0094462335f, 0.28213564f, -0.3249298f, -0.35243613f, -0.0089042485f, -0.31291538f, -0.0778567f, 0.6770868f, -0.01487204f},
    {0.06966228f, -0.14953704f, 0.06314344f, -0.15127875f, -0.09950832f, 0.2923838f, -0.16688302f, 0.53717875f, -0.123594455f, -0.064843684f, 0.24842936f, 0.01864099f, 0.40257537f, 0.035550877f, 0.34530962f, -0.22581655f, 0.49152213f, 0.32336423f, 0.3258667f, 0.12039613f, 0.16042739f, -0.08818531f, -0.6688319f, 0.10937076f, 0.11578797f, 0.2989774f, 0.100650296f, -0.06703618f, 0.46882245f, 0.2646912f, -0.65341365f, 0.2622057f},
    {0.24262083f, -0.11112622f, -0.12258871f, -0.5085518f, 0.029384546f, 0.117930114f, 0.3156356f, -0.16924028f, -4.477404e-05f, 0.40147015f, 0.3009145f, 0.5696398f, -0.04109916f, 0.26865268f, 0.08037245f, -0.37028003f, 0.45892036f, -0.09461713f, 0.3874332f, -0.17691857f, 0.33784714f, -0.33374578f, -0.3594927f, 0.31070095f, 0.29460183f, -0.3755535f, 0.011807292f, 0.16890301f, 0.10576942f, 0.22040029f, 0.0046013026f, -0.4456197f},
    {0.0943451f, -0.30946606f, 0.3386385f, -0.48623744f, 0.0043766634f, -0.15430985f, -0.33526456f, 0.14468564f, 0.034391925f, 0.37586525f, 0.08705319f, 0.109325975f, 0.12734614f, 0.45213124f, -0.2746873f, -0.012084885f, -0.30295402f, 0.20405957f, -0.21987402f, -0.036058042f, 0.18515177f, -0.031180236f, -0.09316037f, -0.48738888f, 0.09856112f, -0.23406178f, 0.22018279f, -0.23622376f, 0.105327226f, 0.15115684f, 0.14133245f, 0.3020934f},
    {0.4290677f, -0.13788469f, 0.2793964f, 0.27702114f, -0.14950971f, 0.040263094f, 0.35752663f, -0.63471764f, -0.16708145f, 0.15260541f, -0.22969747f, -0.46901467f, 0.15331694f, -0.32786578f, 0.1798809f, -0.50090396f, 0.005700723f, 0.16234927f, 0.04270531f, -0.00035591313f, 0.1598812f, -0.07937047f, -0.106277436f, 0.06527855f, -0.2912176f, -0.7180984f, -0.2746014f, 0.46034092f, 0.01735087f, 0.06750077f, -0.8452554f, 0.13764682f},
    {-0.010069413f, 0.28340346f, -0.82462364f, -0.19852144f, -0.2613584f, -0.3964236f, -0.33424434f, 0.12365022f, 0.22000392f, 0.6150541f, -0.10768715f, -0.18163581f, 0.0057965843f, -0.024166355f, -0.46094757f, 0.17328548f, 0.25504225f, 0.2659244f, 0.13405326f, 0.086844474f, -0.5182882f, -0.48904124f, 0.3522273f, -0.4895009f, -0.18856725f, 0.6953198f, -0.05498827f, 0.21855031f, -0.105585985f, -0.15352596f, 0.1526774f, -0.49913675f},
    {0.1672138f, -0.10804117f, 0.1685689f, 0.118210316f, 0.5336487f, -0.037514713f, 0.016106972f, -0.023444606f, -0.14495735f, -0.3797749f, -0.27904928f, -0.34472728f, 0.90833646f, -0.08846343f, 0.5390998f, 0.056753363f, 0.082477145f, 0.2267799f, 0.091283634f, 0.19368216f, -0.029759033f, 0.06437599f, -0.149311f, -0.07187127f, -0.029475419f, -0.4228461f, -0.031536743f, -0.9526086f, -0.22642747f, 0.07220711f, 0.036493156f, -0.5041038f},
    {0.03168844f, -0.25083786f, 0.4213255f, -0.15100648f, 0.04551606f, -0.12404409f, 0.20357603f, 0.043719076f, -0.5834664f, 0.14425693f, 0.5298901f, -0.13326186f, -0.9768497f, -0.37632397f, -0.17034496f, -0.21633856f, 0.71071017f, -0.40576357f, -0.12970622f, -0.46926f, 0.4563507f, -0.8647573f, 0.03590233f, 0.16030541f, -0.70844054f, -0.09260404f, 0.04241659f, -0.67382646f, -0.4628129f, 0.109062545f, 0.3627953f, 0.19582368f},
    {0.039929308f, -0.19062756f, -0.78128463f, -0.14718793f, 0.15450817f, 0.37260967f, -0.10040997f, -0.19254196f, -0.62179375f, 0.19801931f, -0.13059004f, -0.040522046f, -0.24150193f, -0.6458486f, 0.12729141f, -0.11448983f, -0.33516198f, -0.32269502f, -0.10141679f, -0.0140643325f, 0.032805454f, -0.44125217f, -0.19654761f, -0.213875f, 0.6115966f, -0.47122574f, 0.20700158f, -0.15052943f, -0.10514309f, 0.2234356f, 0.53279185f, 0.11875312f},
    {0.15654127f, 0.3363268f, 0.16069336f, -0.0122372005f, 0.09601344f, -0.35653716f, 0.17993072f, -0.19368438f, -0.23444289f, 0.2662119f, 0.03816994f, 0.20903379f, 0.061279297f, 0.1018193f, -0.37958026f, 0.2068563f, 0.13661146f, 0.35108298f, -0.4058406f, -0.03601485f, -0.16379647f, 0.29070622f, -0.0706602f, -0.36946252f, 0.5116053f, 0.076898836f, 0.006106657f, 0.516119f, 0.11438444f, -0.34927228f, 0.5248646f, -0.015666002f},
};

policy_network_w2.setData(policy_network_w2_inp);
}
{
float policy_network_b2_inp[32][1] { { -0.31531522f }, { 0.34433064f }, { -0.031430043f }, { -0.06458381f }, { -0.32081547f }, { -0.01643433f }, { 0.1303655f }, { 0.24517828f }, { -0.15396701f }, { 0.11376733f }, { 0.08292593f }, { -0.053030297f }, { 0.050725527f }, { 0.018845141f }, { -0.03942179f }, { -0.46852106f }, { -0.035739042f }, { 0.28601846f }, { 0.059825778f }, { 0.5757298f }, { -0.016366266f }, { -0.070213094f }, { -0.118759856f }, { 0.047700826f }, { 0.10512366f }, { 0.18199067f }, { 0.14719176f }, { -0.31421334f }, { 0.16155341f }, { 0.21954435f }, { 0.042090733f }, { -0.13182579f } };

policy_network_b2.setData(policy_network_b2_inp);
}

{
float policy_network_w3_inp[4][32] {
    {0.111014865f, -0.41830125f, -0.20335047f, 0.06634524f, -0.21192336f, 0.07009462f, -0.10878712f, 0.15150596f, -0.26584324f, -0.02101209f, -0.31514364f, 0.20157832f, 0.36397797f, 0.11335242f, -0.07216063f, -0.024705892f, 0.06314151f, -0.22450352f, 0.20958169f, -0.38092285f, 0.2081488f, 0.83173186f, -0.14164564f, -0.062467672f, 0.09408143f, 0.05414139f, -0.05648774f, -0.14932816f, -0.2788086f, -0.18941276f, 0.0045103603f, 0.063208796f},
    {0.06779883f, -0.15852025f, -0.59935206f, 0.039361045f, -0.09253202f, 0.19229904f, 0.034865443f, -0.38716882f, -0.31127605f, 0.3577366f, 0.13147436f, -0.04562891f, -0.11113277f, 0.23397018f, 0.038881596f, -0.029534655f, 0.2557702f, -0.021084175f, 0.112321526f, 0.1931094f, 0.10024863f, 0.3975251f, -0.007805613f, -0.16766205f, -0.23771626f, -0.029562702f, 0.40411183f, 0.36129722f, -0.1355099f, -0.10546492f, 0.078172944f, 0.016419638f},
    {-0.16723886f, 0.106038034f, 0.058328204f, -0.039590307f, 0.031977657f, -0.08398184f, -0.04732137f, 0.36366117f, -0.08444103f, -0.081757724f, -0.07411825f, -0.05552497f, -0.08513917f, 0.29552543f, 0.40441617f, -0.15242779f, 0.22494453f, 0.24944277f, -0.26568f, -0.048144158f, -0.066696696f, -1.0201257f, -0.19330181f, 0.28600743f, -0.033434283f, -0.06804225f, 0.064695746f, 0.03899308f, 0.2318419f, -0.55184186f, -0.2065325f, -0.10471718f},
    {-0.14220713f, -0.50237346f, -0.007029748f, -0.20062599f, 0.38429248f, -0.115992315f, -0.3248289f, -0.274987f, -0.25781167f, -0.25568098f, 0.030599797f, 0.019607252f, -0.065829165f, 0.33045977f, -0.07399183f, -0.19839877f, -0.28351027f, -0.09949903f, -0.193193f, -0.17832723f, 0.022194464f, -0.40835387f, 0.39240497f, 0.36418736f, -0.022330431f, 0.28546178f, -0.02623227f, -0.13476841f, -0.009189993f, 0.23034322f, 0.25412068f, 0.036626693f},
};
policy_network_w3.setData(policy_network_w3_inp);
}
{
float policy_network_b3_inp[4][1] { { 0.052487258f }, { 0.007309009f }, { 0.06450168f }, { -0.005422031f } };
policy_network_b3.setData(policy_network_b3_inp);
}

	_last_execution = hrt_absolute_time();

	return true;
}

void
ControlAllocator::parameters_updated()
{
	_has_slew_rate = false;

	for (int i = 0; i < MAX_NUM_MOTORS; ++i) {
		param_get(_param_handles.slew_rate_motors[i], &_params.slew_rate_motors[i]);
		_has_slew_rate |= _params.slew_rate_motors[i] > FLT_EPSILON;
	}

	for (int i = 0; i < MAX_NUM_SERVOS; ++i) {
		param_get(_param_handles.slew_rate_servos[i], &_params.slew_rate_servos[i]);
		_has_slew_rate |= _params.slew_rate_servos[i] > FLT_EPSILON;
	}

	// Allocation method & effectiveness source
	// Do this first: in case a new method is loaded, it will be configured below
	bool updated = update_effectiveness_source();
	update_allocation_method(updated); // must be called after update_effectiveness_source()

	if (_num_control_allocation == 0) {
		return;
	}

	for (int i = 0; i < _num_control_allocation; ++i) {
		_control_allocation[i]->updateParameters();
	}

	update_effectiveness_matrix_if_needed(EffectivenessUpdateReason::CONFIGURATION_UPDATE);
}

void
ControlAllocator::update_allocation_method(bool force)
{
	AllocationMethod configured_method = (AllocationMethod)_param_ca_method.get();

	if (!_actuator_effectiveness) {
		PX4_ERR("_actuator_effectiveness null");
		return;
	}

	if (_allocation_method_id != configured_method || force) {

		matrix::Vector<float, NUM_ACTUATORS> actuator_sp[ActuatorEffectiveness::MAX_NUM_MATRICES];

		// Cleanup first
		for (int i = 0; i < ActuatorEffectiveness::MAX_NUM_MATRICES; ++i) {
			// Save current state
			if (_control_allocation[i] != nullptr) {
				actuator_sp[i] = _control_allocation[i]->getActuatorSetpoint();
			}

			delete _control_allocation[i];
			_control_allocation[i] = nullptr;
		}

		_num_control_allocation = _actuator_effectiveness->numMatrices();

		AllocationMethod desired_methods[ActuatorEffectiveness::MAX_NUM_MATRICES];
		_actuator_effectiveness->getDesiredAllocationMethod(desired_methods);

		bool normalize_rpy[ActuatorEffectiveness::MAX_NUM_MATRICES];
		_actuator_effectiveness->getNormalizeRPY(normalize_rpy);

		for (int i = 0; i < _num_control_allocation; ++i) {
			AllocationMethod method = configured_method;

			if (configured_method == AllocationMethod::AUTO) {
				method = desired_methods[i];
			}

			switch (method) {
			case AllocationMethod::PSEUDO_INVERSE:
				_control_allocation[i] = new ControlAllocationPseudoInverse();
				break;

			case AllocationMethod::SEQUENTIAL_DESATURATION:
				_control_allocation[i] = new ControlAllocationSequentialDesaturation();
				break;

			default:
				PX4_ERR("Unknown allocation method");
				break;
			}

			if (_control_allocation[i] == nullptr) {
				PX4_ERR("alloc failed");
				_num_control_allocation = 0;

			} else {
				_control_allocation[i]->setNormalizeRPY(normalize_rpy[i]);
				_control_allocation[i]->setActuatorSetpoint(actuator_sp[i]);
			}
		}

		_allocation_method_id = configured_method;
	}
}

bool
ControlAllocator::update_effectiveness_source()
{
	const EffectivenessSource source = (EffectivenessSource)_param_ca_airframe.get();

	if (_effectiveness_source_id != source) {

		// try to instanciate new effectiveness source
		ActuatorEffectiveness *tmp = nullptr;

		switch (source) {
		case EffectivenessSource::NONE:
		case EffectivenessSource::MULTIROTOR:
			tmp = new ActuatorEffectivenessMultirotor(this);
			break;

		case EffectivenessSource::STANDARD_VTOL:
			tmp = new ActuatorEffectivenessStandardVTOL(this);
			break;

		case EffectivenessSource::TILTROTOR_VTOL:
			tmp = new ActuatorEffectivenessTiltrotorVTOL(this);
			break;

		case EffectivenessSource::TAILSITTER_VTOL:
			tmp = new ActuatorEffectivenessTailsitterVTOL(this);
			break;

		case EffectivenessSource::ROVER_ACKERMANN:
			tmp = new ActuatorEffectivenessRoverAckermann();
			break;

		case EffectivenessSource::ROVER_DIFFERENTIAL:
			tmp = new ActuatorEffectivenessRoverDifferential();
			break;

		case EffectivenessSource::FIXED_WING:
			tmp = new ActuatorEffectivenessFixedWing(this);
			break;

		case EffectivenessSource::MOTORS_6DOF: // just a different UI from MULTIROTOR
			tmp = new ActuatorEffectivenessRotors(this);
			break;

		case EffectivenessSource::MULTIROTOR_WITH_TILT:
			tmp = new ActuatorEffectivenessMCTilt(this);
			break;

		case EffectivenessSource::CUSTOM:
			tmp = new ActuatorEffectivenessCustom(this);
			break;

		case EffectivenessSource::HELICOPTER:
			tmp = new ActuatorEffectivenessHelicopter(this);
			break;

		default:
			PX4_ERR("Unknown airframe");
			break;
		}

		// Replace previous source with new one
		if (tmp == nullptr) {
			// It did not work, forget about it
			PX4_ERR("Actuator effectiveness init failed");
			_param_ca_airframe.set((int)_effectiveness_source_id);

		} else {
			// Swap effectiveness sources
			delete _actuator_effectiveness;
			_actuator_effectiveness = tmp;

			// Save source id
			_effectiveness_source_id = source;
		}

		return true;
	}

	return false;
}

void
ControlAllocator::Run()
{
	if (should_exit()) {
		_vehicle_torque_setpoint_sub.unregisterCallback();
		_vehicle_thrust_setpoint_sub.unregisterCallback();
		exit_and_cleanup();
		return;
	}

	perf_begin(_loop_perf);
	// auto start = std::chrono::high_resolution_clock::now();


#ifndef ENABLE_LOCKSTEP_SCHEDULER // Backup schedule would interfere with lockstep
	// Push backup schedule
	ScheduleDelayed(50_ms);
#endif

	// Check if parameters have changed
	if (_parameter_update_sub.updated() && !_armed) {
		// clear update
		parameter_update_s param_update;
		_parameter_update_sub.copy(&param_update);

		if (_handled_motor_failure_bitmask == 0) {
			// We don't update the geometry after an actuator failure, as it could lead to unexpected results
			// (e.g. a user could add/remove motors, such that the bitmask isn't correct anymore)
			updateParams();
			parameters_updated();
		}
	}

	if (_num_control_allocation == 0 || _actuator_effectiveness == nullptr) {
		return;
	}

	{
		vehicle_status_s vehicle_status;

		if (_vehicle_status_sub.update(&vehicle_status)) {

			_armed = vehicle_status.arming_state == vehicle_status_s::ARMING_STATE_ARMED;

			ActuatorEffectiveness::FlightPhase flight_phase{ActuatorEffectiveness::FlightPhase::HOVER_FLIGHT};

			// Check if the current flight phase is HOVER or FIXED_WING
			if (vehicle_status.vehicle_type == vehicle_status_s::VEHICLE_TYPE_ROTARY_WING) {
				flight_phase = ActuatorEffectiveness::FlightPhase::HOVER_FLIGHT;

			} else {
				flight_phase = ActuatorEffectiveness::FlightPhase::FORWARD_FLIGHT;
			}

			// Special cases for VTOL in transition
			if (vehicle_status.is_vtol && vehicle_status.in_transition_mode) {
				if (vehicle_status.in_transition_to_fw) {
					flight_phase = ActuatorEffectiveness::FlightPhase::TRANSITION_HF_TO_FF;

				} else {
					flight_phase = ActuatorEffectiveness::FlightPhase::TRANSITION_FF_TO_HF;
				}
			}

			// Forward to effectiveness source
			_actuator_effectiveness->setFlightPhase(flight_phase);
		}
	}

	// Guard against too small (< 0.2ms) and too large (> 20ms) dt's.
	const hrt_abstime now = hrt_absolute_time();
	const float dt = math::constrain(((now - _last_run) / 1e6f), 0.0002f, 0.02f);

	bool do_update = false;
	vehicle_torque_setpoint_s vehicle_torque_setpoint;
	vehicle_thrust_setpoint_s vehicle_thrust_setpoint;

	// Run allocator on torque changes
	if (_vehicle_torque_setpoint_sub.update(&vehicle_torque_setpoint)) {
		_torque_sp = matrix::Vector3f(vehicle_torque_setpoint.xyz);

		do_update = true;
		_timestamp_sample = vehicle_torque_setpoint.timestamp_sample;

	}

	// Also run allocator on thrust setpoint changes if the torque setpoint
	// has not been updated for more than 5ms
	if (_vehicle_thrust_setpoint_sub.update(&vehicle_thrust_setpoint)) {
		_thrust_sp = matrix::Vector3f(vehicle_thrust_setpoint.xyz);

		if (dt > 5_ms) {
			do_update = true;
			_timestamp_sample = vehicle_thrust_setpoint.timestamp_sample;
		}
	}

	if (do_update) {
		_last_run = now;

		check_for_motor_failures();

		update_effectiveness_matrix_if_needed(EffectivenessUpdateReason::NO_EXTERNAL_UPDATE);

		// Set control setpoint vector(s)
		matrix::Vector<float, NUM_AXES> c[ActuatorEffectiveness::MAX_NUM_MATRICES];
		c[0](0) = _torque_sp(0);
		c[0](1) = _torque_sp(1);
		c[0](2) = _torque_sp(2);
		c[0](3) = _thrust_sp(0);
		c[0](4) = _thrust_sp(1);
		c[0](5) = _thrust_sp(2);

		if (_num_control_allocation > 1) {
			if (_vehicle_torque_setpoint1_sub.copy(&vehicle_torque_setpoint)) {
				c[1](0) = vehicle_torque_setpoint.xyz[0];
				c[1](1) = vehicle_torque_setpoint.xyz[1];
				c[1](2) = vehicle_torque_setpoint.xyz[2];
			}

			if (_vehicle_thrust_setpoint1_sub.copy(&vehicle_thrust_setpoint)) {
				c[1](3) = vehicle_thrust_setpoint.xyz[0];
				c[1](4) = vehicle_thrust_setpoint.xyz[1];
				c[1](5) = vehicle_thrust_setpoint.xyz[2];
			}
		}

		for (int i = 0; i < _num_control_allocation; ++i) {

			_control_allocation[i]->setControlSetpoint(c[i]);

			// Do allocation
			_control_allocation[i]->allocate();
			_actuator_effectiveness->allocateAuxilaryControls(dt, i, _control_allocation[i]->_actuator_sp); //flaps and spoilers
			_actuator_effectiveness->updateSetpoint(c[i], i, _control_allocation[i]->_actuator_sp,
								_control_allocation[i]->getActuatorMin(), _control_allocation[i]->getActuatorMax());

			if (_has_slew_rate) {
				_control_allocation[i]->applySlewRateLimit(dt);
			}

			_control_allocation[i]->clipActuatorSetpoint();
		}
	}

	// Publish actuator setpoint and allocator status
	publish_actuator_controls();

	// Publish status at limited rate, as it's somewhat expensive and we use it for slower dynamics
	// (i.e. anti-integrator windup)
	if (now - _last_status_pub >= 5_ms) {
		publish_control_allocator_status(0);

		if (_num_control_allocation > 1) {
			publish_control_allocator_status(1);
		}

		_last_status_pub = now;
	}

	perf_end(_loop_perf);
	// auto end = std::chrono::high_resolution_clock::now();
	// std::chrono::microseconds duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
	// std::cout << "ControlAllocator.cpp PID time taken: " << duration.count() << " microseconds" << std::endl;
}

void
ControlAllocator::update_effectiveness_matrix_if_needed(EffectivenessUpdateReason reason)
{
	ActuatorEffectiveness::Configuration config{};

	if (reason == EffectivenessUpdateReason::NO_EXTERNAL_UPDATE
	    && hrt_elapsed_time(&_last_effectiveness_update) < 100_ms) { // rate-limit updates
		return;
	}

	if (_actuator_effectiveness->getEffectivenessMatrix(config, reason)) {
		_last_effectiveness_update = hrt_absolute_time();

		memcpy(_control_allocation_selection_indexes, config.matrix_selection_indexes,
		       sizeof(_control_allocation_selection_indexes));

		// Get the minimum and maximum depending on type and configuration
		ActuatorEffectiveness::ActuatorVector minimum[ActuatorEffectiveness::MAX_NUM_MATRICES];
		ActuatorEffectiveness::ActuatorVector maximum[ActuatorEffectiveness::MAX_NUM_MATRICES];
		ActuatorEffectiveness::ActuatorVector slew_rate[ActuatorEffectiveness::MAX_NUM_MATRICES];
		int actuator_idx = 0;
		int actuator_idx_matrix[ActuatorEffectiveness::MAX_NUM_MATRICES] {};

		actuator_servos_trim_s trims{};
		static_assert(actuator_servos_trim_s::NUM_CONTROLS == actuator_servos_s::NUM_CONTROLS, "size mismatch");

		for (int actuator_type = 0; actuator_type < (int)ActuatorType::COUNT; ++actuator_type) {
			_num_actuators[actuator_type] = config.num_actuators[actuator_type];

			for (int actuator_type_idx = 0; actuator_type_idx < config.num_actuators[actuator_type]; ++actuator_type_idx) {
				if (actuator_idx >= NUM_ACTUATORS) {
					_num_actuators[actuator_type] = 0;
					PX4_ERR("Too many actuators");
					break;
				}

				int selected_matrix = _control_allocation_selection_indexes[actuator_idx];

				if ((ActuatorType)actuator_type == ActuatorType::MOTORS) {
					if (actuator_type_idx >= MAX_NUM_MOTORS) {
						PX4_ERR("Too many motors");
						_num_actuators[actuator_type] = 0;
						break;
					}

					if (_param_r_rev.get() & (1u << actuator_type_idx)) {
						minimum[selected_matrix](actuator_idx_matrix[selected_matrix]) = -1.f;

					} else {
						minimum[selected_matrix](actuator_idx_matrix[selected_matrix]) = 0.f;
					}

					slew_rate[selected_matrix](actuator_idx_matrix[selected_matrix]) = _params.slew_rate_motors[actuator_type_idx];

				} else if ((ActuatorType)actuator_type == ActuatorType::SERVOS) {
					if (actuator_type_idx >= MAX_NUM_SERVOS) {
						PX4_ERR("Too many servos");
						_num_actuators[actuator_type] = 0;
						break;
					}

					minimum[selected_matrix](actuator_idx_matrix[selected_matrix]) = -1.f;
					slew_rate[selected_matrix](actuator_idx_matrix[selected_matrix]) = _params.slew_rate_servos[actuator_type_idx];
					trims.trim[actuator_type_idx] = config.trim[selected_matrix](actuator_idx_matrix[selected_matrix]);

				} else {
					minimum[selected_matrix](actuator_idx_matrix[selected_matrix]) = -1.f;
				}

				maximum[selected_matrix](actuator_idx_matrix[selected_matrix]) = 1.f;

				++actuator_idx_matrix[selected_matrix];
				++actuator_idx;
			}
		}

		// Handle failed actuators
		if (_handled_motor_failure_bitmask) {
			actuator_idx = 0;
			memset(&actuator_idx_matrix, 0, sizeof(actuator_idx_matrix));

			for (int motors_idx = 0; motors_idx < _num_actuators[0] && motors_idx < actuator_motors_s::NUM_CONTROLS; motors_idx++) {
				int selected_matrix = _control_allocation_selection_indexes[actuator_idx];

				if (_handled_motor_failure_bitmask & (1 << motors_idx)) {
					ActuatorEffectiveness::EffectivenessMatrix &matrix = config.effectiveness_matrices[selected_matrix];

					for (int i = 0; i < NUM_AXES; i++) {
						matrix(i, actuator_idx_matrix[selected_matrix]) = 0.0f;
					}
				}

				++actuator_idx_matrix[selected_matrix];
				++actuator_idx;
			}
		}

		for (int i = 0; i < _num_control_allocation; ++i) {
			_control_allocation[i]->setActuatorMin(minimum[i]);
			_control_allocation[i]->setActuatorMax(maximum[i]);
			_control_allocation[i]->setSlewRateLimit(slew_rate[i]);

			//prev_action Set all the elements of a row to 0 if that row has weak authority.
			// That ensures that the algorithm doesn't try to control axes with only marginal control authority,
			// which in turn would degrade the control of the main axes that actually should and can be controlled.

			ActuatorEffectiveness::EffectivenessMatrix &matrix = config.effectiveness_matrices[i];

			for (int n = 0; n < NUM_AXES; n++) {
				bool all_entries_small = true;

				for (int m = 0; m < config.num_actuators_matrix[i]; m++) {
					if (fabsf(matrix(n, m)) > 0.05f) {
						all_entries_small = false;
					}
				}

				if (all_entries_small) {
					matrix.row(n) = 0.f;
				}
			}

			// Assign control effectiveness matrix
			int total_num_actuators = config.num_actuators_matrix[i];
			_control_allocation[i]->setEffectivenessMatrix(config.effectiveness_matrices[i], config.trim[i],
					config.linearization_point[i], total_num_actuators, reason == EffectivenessUpdateReason::CONFIGURATION_UPDATE);
		}

		trims.timestamp = hrt_absolute_time();
		_actuator_servos_trim_pub.publish(trims);
	}
}

void
ControlAllocator::publish_control_allocator_status(int matrix_index)
{
	control_allocator_status_s control_allocator_status{};
	control_allocator_status.timestamp = hrt_absolute_time();

	// TODO: disabled motors (?)

	// Allocated control
	const matrix::Vector<float, NUM_AXES> &allocated_control = _control_allocation[matrix_index]->getAllocatedControl();

	// Unallocated control
	const matrix::Vector<float, NUM_AXES> unallocated_control = _control_allocation[matrix_index]->getControlSetpoint() -
			allocated_control;
	control_allocator_status.unallocated_torque[0] = unallocated_control(0);
	control_allocator_status.unallocated_torque[1] = unallocated_control(1);
	control_allocator_status.unallocated_torque[2] = unallocated_control(2);
	control_allocator_status.unallocated_thrust[0] = unallocated_control(3);
	control_allocator_status.unallocated_thrust[1] = unallocated_control(4);
	control_allocator_status.unallocated_thrust[2] = unallocated_control(5);

	// override control_allocator_status in customized saturation logic for certain effectiveness types
	_actuator_effectiveness->getUnallocatedControl(matrix_index, control_allocator_status);

	// Allocation success flags
	control_allocator_status.torque_setpoint_achieved = (Vector3f(control_allocator_status.unallocated_torque[0],
			control_allocator_status.unallocated_torque[1],
			control_allocator_status.unallocated_torque[2]).norm_squared() < 1e-6f);
	control_allocator_status.thrust_setpoint_achieved = (Vector3f(control_allocator_status.unallocated_thrust[0],
			control_allocator_status.unallocated_thrust[1],
			control_allocator_status.unallocated_thrust[2]).norm_squared() < 1e-6f);

	// Actuator saturation
	const matrix::Vector<float, NUM_ACTUATORS> &actuator_sp = _control_allocation[matrix_index]->getActuatorSetpoint();
	const matrix::Vector<float, NUM_ACTUATORS> &actuator_min = _control_allocation[matrix_index]->getActuatorMin();
	const matrix::Vector<float, NUM_ACTUATORS> &actuator_max = _control_allocation[matrix_index]->getActuatorMax();

	for (int i = 0; i < NUM_ACTUATORS; i++) {
		if (actuator_sp(i) > (actuator_max(i) - FLT_EPSILON)) {
			control_allocator_status.actuator_saturation[i] = control_allocator_status_s::ACTUATOR_SATURATION_UPPER;

		} else if (actuator_sp(i) < (actuator_min(i) + FLT_EPSILON)) {
			control_allocator_status.actuator_saturation[i] = control_allocator_status_s::ACTUATOR_SATURATION_LOWER;
		}
	}

	// Handled motor failures
	control_allocator_status.handled_motor_failure_mask = _handled_motor_failure_bitmask;

	_control_allocator_status_pub[matrix_index].publish(control_allocator_status);
}

void
ControlAllocator::publish_actuator_controls()
{
	if (_vehicle_control_mode_sub.updated()) {
		_vehicle_control_mode_sub.update(&_vehicle_control_mode);
	}

	actuator_motors_s actuator_motors;
	actuator_motors.timestamp = hrt_absolute_time();
	actuator_motors.timestamp_sample = _timestamp_sample;

	actuator_servos_s actuator_servos;
	actuator_servos.timestamp = actuator_motors.timestamp;
	actuator_servos.timestamp_sample = _timestamp_sample;

	actuator_motors.reversible_flags = _param_r_rev.get();

	int actuator_idx = 0;
	int actuator_idx_matrix[ActuatorEffectiveness::MAX_NUM_MATRICES] {};

	uint32_t stopped_motors = _actuator_effectiveness->getStoppedMotors() | _handled_motor_failure_bitmask;

	// motors
	int motors_idx;

	for (motors_idx = 0; motors_idx < _num_actuators[0] && motors_idx < actuator_motors_s::NUM_CONTROLS; motors_idx++) {
		int selected_matrix = _control_allocation_selection_indexes[actuator_idx];
		float actuator_sp = _control_allocation[selected_matrix]->getActuatorSetpoint()(actuator_idx_matrix[selected_matrix]);
		actuator_motors.control[motors_idx] = PX4_ISFINITE(actuator_sp) ? actuator_sp : NAN;

		if (stopped_motors & (1u << motors_idx)) {
			actuator_motors.control[motors_idx] = NAN;
		}

		++actuator_idx_matrix[selected_matrix];
		++actuator_idx;
	}

	for (int i = motors_idx; i < actuator_motors_s::NUM_CONTROLS; i++) {
		actuator_motors.control[i] = NAN;
	}





	if(_vehicle_control_mode.flag_control_ai_enabled == false)
	{
		//const hrt_abstime now = hrt_absolute_time();
		//auto dt = (now - _last_execution) / 1000; //time since start in ms
		// if(dt >= 200)
		// {
		// std::cout << "\n" << actuator_motors.control[2] << "," << actuator_motors.control[0] << "," << actuator_motors.control[3] << "," << actuator_motors.control[1] << ",";

		// fs << std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count() << "," << actuator_motors.control[2] << "\n";
		//fs << dt << "," << actuator_motors.control[2] << "\n";
		//      std::cout << "\n" << actuator_motors.control[2];
		//      _last_execution = hrt_absolute_time();
		// }
		//actuator_motors.control[0] = actuator_motors.control[0] * (float) 0.7;
		_actuator_motors_pub.publish(actuator_motors);
	}
	else
	{
			// Guard against too small seconds(< 0.2ms) and too large (> 20ms) dt's.
			const hrt_abstime now = hrt_absolute_time();
			auto dt = (now - _last_execution) / 1000;

			// auto start = std::chrono::high_resolution_clock::now();
			if(dt >= 8)
			{
				if(_local_pos_sub.updated())
				{
					_local_pos_sub.update(&vehicle_local_position);
				}
				if(_vehicle_angular_velocity_sub.updated())
				{
					_vehicle_angular_velocity_sub.update(&angular_velocity);
				}
				if(_vehicle_attitude_sub.updated())
				{
					_vehicle_attitude_sub.update(&vehicle_attitude);
				}

				if (_hover_thrust_estimate_sub.updated()) {
					_hover_thrust_estimate_sub.update(&hte);
				}


				matrix::Quaternion<float> q(vehicle_attitude.q);

				matrix::Euler<float> e(q);

				float y = 1.0f - vehicle_local_position.y;
				float x = 1.0f - vehicle_local_position.x;
				float z = 2.0f   - -vehicle_local_position.z;


				// y += 1.0f;
				// x += 0.77f;
				// z += 0.27f;

				float input_inp [16] {
					y, x,  z, //vehicle location position
					-(e.psi() - 1.57f), -e.theta(), e.phi(),   // zyx
					vehicle_local_position.vy, vehicle_local_position.vx,   -vehicle_local_position.vz, // vehicle linear velocity
					angular_velocity.xyz[0],  -angular_velocity.xyz[1], -angular_velocity.xyz[2], //might need to swap 0 and 2 (so zyx)
					a0, a1, a2, a3
				};
				// std::cout << "x: " << vehicle_local_position.y << "\n";
				// std::cout << "y: " << vehicle_local_position.x << "\n";
				// std::cout << "z: " << vehicle_local_position.z << "\n";


				matrix::Matrix<float, 1, 16> input(input_inp);

				matrix::Matrix<float, 32, 1> res = policy_network_w0 * input.transpose();
				res += policy_network_b0;
				res.mrelu();
				matrix::Matrix<float, 32, 1> res2 = policy_network_w1 * res;
				res2 += policy_network_b1;
				res2.mrelu();
				matrix::Matrix<float, 32, 1> res3 = policy_network_w2 * res2;
				res3 += policy_network_b2;
				res3.mrelu();
				matrix::Matrix<float, 4, 1> res4 = policy_network_w3 * res3;
				res4 += policy_network_b3;
				res4.mtanh();

				// std::cout << "px" << input_inp[0] << "\n";
				// std::cout << "py" << input_inp[1] << "\n";
				// std::cout << "pz" << input_inp[2] << "\n";
				// std::cout << "rz" << input_inp[3] << "\n";
				// std::cout << "ry" << input_inp[4] << "\n";
				// std::cout << "rx" << input_inp[5] << "\n";
				// std::cout << "vx" << input_inp[6] << "\n";
				// std::cout << "vy" << input_inp[7] << "\n";
				// std::cout << "vz" << input_inp[8] << "\n";
				// std::cout << "ax" << input_inp[9] << "\n";
				// std::cout << "ay" << input_inp[10] << "\n";
				// std::cout << "az" << input_inp[11] << "\n";

				if(hte.valid && hte.hover_thrust > min_hover_thrust && (hte.hover_thrust - hover_thrust) <= 0.1f) // this is to ensure that no wild changes are made the hte
				{
					hover_thrust = hte.hover_thrust;
				}

				float pertubated_hte = hover_thrust;
				float mfte = 1.0f - pertubated_hte;

				a0 = res4(0, 0) <= 0 ? pertubated_hte * res4(0, 0) + pertubated_hte : mfte * res4(0, 0) + pertubated_hte;
				a1 = res4(1, 0) <= 0 ? pertubated_hte * res4(1, 0) + pertubated_hte : mfte * res4(1, 0) + pertubated_hte;
				a2 = res4(2, 0) <= 0 ? pertubated_hte * res4(2, 0) + pertubated_hte : mfte * res4(2, 0) + pertubated_hte;
				a3 = res4(3, 0) <= 0 ? pertubated_hte * res4(3, 0) + pertubated_hte : mfte * res4(3, 0) + pertubated_hte;
				//a1 = a1 * (float) 0.7;

				_last_execution = hrt_absolute_time();
			}
			// auto end = std::chrono::high_resolution_clock::now();

			// std::chrono::microseconds duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

    			// std::cout << "ControlAllocator.cpp with NN time taken: " << duration.count() << " microseconds" << std::endl;
			//config 1
			// actuator_motors.control[0] = a0;
			// actuator_motors.control[1] = a2;
			// actuator_motors.control[2] = a1;
			// actuator_motors.control[3] = a3;

			//config 2 (*)
			// actuator_motors.control[0] = a0;
			// actuator_motors.control[1] = a2;
			// actuator_motors.control[2] = a3;
			// actuator_motors.control[3] = a1;

			//config 3 (*****)
			actuator_motors.control[0] = a1;
			actuator_motors.control[1] = a3;
			actuator_motors.control[2] = a0;
			actuator_motors.control[3] = a2;

			// std::cout << "r0 " << a1 << " r1 " << a3 << " r2 " << a0 << " r3 " << a2 << "\n";


			//config 4
			// actuator_motors.control[0] = a1;
			// actuator_motors.control[1] = a3;
			// actuator_motors.control[2] = a2;
			// actuator_motors.control[3] = a0;

			//config 5
			// actuator_motors.control[0] = a2;
			// actuator_motors.control[1] = a0;
			// actuator_motors.control[2] = a1;
			// actuator_motors.control[3] = a3;

			//config 6
			// actuator_motors.control[0] = a2;
			// actuator_motors.control[1] = a0;
			// actuator_motors.control[2] = a3;
			// actuator_motors.control[3] = a1;

			//config 7
			// actuator_motors.control[0] = a3;
			// actuator_motors.control[1] = a1;
			// actuator_motors.control[2] = a0;
			// actuator_motors.control[3] = a2;

			//config 8
			// actuator_motors.control[0] = a3;
			// actuator_motors.control[1] = a1;
			// actuator_motors.control[2] = a2;
			// actuator_motors.control[3] = a0;

			_actuator_motors_pub.publish(actuator_motors);

	}

	// std::cout << "a0: " << actuator_motors.control[0] << "\n";
	// std::cout << "a1: " << actuator_motors.control[1] << "\n";
	// std::cout << "a2: " << actuator_motors.control[2] << "\n";
	// std::cout << "a3: " << actuator_motors.control[3] << "\n";

	// servos
	if (_num_actuators[1] > 0) {
		int servos_idx;

		for (servos_idx = 0; servos_idx < _num_actuators[1] && servos_idx < actuator_servos_s::NUM_CONTROLS; servos_idx++) {
			int selected_matrix = _control_allocation_selection_indexes[actuator_idx];
			float actuator_sp = _control_allocation[selected_matrix]->getActuatorSetpoint()(actuator_idx_matrix[selected_matrix]);
			actuator_servos.control[servos_idx] = PX4_ISFINITE(actuator_sp) ? actuator_sp : NAN;
			++actuator_idx_matrix[selected_matrix];
			++actuator_idx;
		}

		for (int i = servos_idx; i < actuator_servos_s::NUM_CONTROLS; i++) {
			actuator_servos.control[i] = NAN;
		}

		_actuator_servos_pub.publish(actuator_servos);
	}
}

void
ControlAllocator::check_for_motor_failures()
{
	failure_detector_status_s failure_detector_status;

	if ((FailureMode)_param_ca_failure_mode.get() > FailureMode::IGNORE
	    && _failure_detector_status_sub.update(&failure_detector_status)) {
		if (failure_detector_status.fd_motor) {

			if (_handled_motor_failure_bitmask != failure_detector_status.motor_failure_mask) {
				// motor failure bitmask changed
				switch ((FailureMode)_param_ca_failure_mode.get()) {
				case FailureMode::REMOVE_FIRST_FAILING_MOTOR: {
						// Count number of failed motors
						const int num_motors_failed = math::countSetBits(failure_detector_status.motor_failure_mask);

						// Only handle if it is the first failure
						if (_handled_motor_failure_bitmask == 0 && num_motors_failed == 1) {
							_handled_motor_failure_bitmask = failure_detector_status.motor_failure_mask;
							PX4_WARN("Removing motor from allocation (0x%x)", _handled_motor_failure_bitmask);

							for (int i = 0; i < _num_control_allocation; ++i) {
								_control_allocation[i]->setHadActuatorFailure(true);
							}

							update_effectiveness_matrix_if_needed(EffectivenessUpdateReason::MOTOR_ACTIVATION_UPDATE);
						}
					}
					break;

				default:
					break;
				}

			}

		} else if (_handled_motor_failure_bitmask != 0) {
			// Clear bitmask completely
			PX4_INFO("Restoring all motors");
			_handled_motor_failure_bitmask = 0;

			for (int i = 0; i < _num_control_allocation; ++i) {
				_control_allocation[i]->setHadActuatorFailure(false);
			}

			update_effectiveness_matrix_if_needed(EffectivenessUpdateReason::MOTOR_ACTIVATION_UPDATE);
		}
	}
}

int ControlAllocator::task_spawn(int argc, char *argv[])
{
	ControlAllocator *instance = new ControlAllocator();

	if (instance) {
		_object.store(instance);
		_task_id = task_id_is_work_queue;

		if (instance->init()) {
			return PX4_OK;
		}

	} else {
		PX4_ERR("alloc failed");
	}

	delete instance;
	_object.store(nullptr);
	_task_id = -1;

	return PX4_ERROR;
}

int ControlAllocator::print_status()
{
	PX4_INFO("Running");

	// Print current allocation method
	switch (_allocation_method_id) {
	case AllocationMethod::NONE:
		PX4_INFO("Method: None");
		break;

	case AllocationMethod::PSEUDO_INVERSE:
		PX4_INFO("Method: Pseudo-inverse");
		break;

	case AllocationMethod::SEQUENTIAL_DESATURATION:
		PX4_INFO("Method: Sequential desaturation");
		break;

	case AllocationMethod::AUTO:
		PX4_INFO("Method: Auto");
		break;
	}

	// Print current airframe
	if (_actuator_effectiveness != nullptr) {
		PX4_INFO("Effectiveness Source: %s", _actuator_effectiveness->name());
	}

	// Print current effectiveness matrix
	for (int i = 0; i < _num_control_allocation; ++i) {
		const ActuatorEffectiveness::EffectivenessMatrix &effectiveness = _control_allocation[i]->getEffectivenessMatrix();

		if (_num_control_allocation > 1) {
			PX4_INFO("Instance: %i", i);
		}

		PX4_INFO("  Effectiveness.T =");
		effectiveness.T().print();
		PX4_INFO("  minimum =");
		_control_allocation[i]->getActuatorMin().T().print();
		PX4_INFO("  maximum =");
		_control_allocation[i]->getActuatorMax().T().print();
		PX4_INFO("  Configured actuators: %i", _control_allocation[i]->numConfiguredActuators());
	}

	if (_handled_motor_failure_bitmask) {
		PX4_INFO("Failed motors: %i (0x%x)", math::countSetBits(_handled_motor_failure_bitmask),
			 _handled_motor_failure_bitmask);
	}

	// Print perf
	perf_print_counter(_loop_perf);

	return 0;
}

int ControlAllocator::custom_command(int argc, char *argv[])
{
	return print_usage("unknown command");
}

int ControlAllocator::print_usage(const char *reason)
{
	if (reason) {
		PX4_WARN("%s\n", reason);
	}

	PRINT_MODULE_DESCRIPTION(
		R"DESCR_STR(
### Description
This implements control allocation. It takes torque and thrust setpoints
as inputs and outputs actuator setpoint messages.
)DESCR_STR");

	PRINT_MODULE_USAGE_NAME("control_allocator", "controller");
	PRINT_MODULE_USAGE_COMMAND("start");
	PRINT_MODULE_USAGE_DEFAULT_COMMANDS();

	return 0;
}

/**
 * Control Allocator app start / stop handling function
 */
extern "C" __EXPORT int control_allocator_main(int argc, char *argv[]);

int control_allocator_main(int argc, char *argv[])
{
	return ControlAllocator::main(argc, argv);
}
